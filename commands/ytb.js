
const sendMessage = require('../handles/sendMessage');
const axios = require('axios');

// Stockage des recherches des utilisateurs
const userSearches = {};

module.exports = async (senderId, prompt) => {
    try {
        // V√©rifier si l'utilisateur a d√©j√† effectu√© une recherche
        if (!userSearches[senderId]) {
            userSearches[senderId] = {
                query: '',
                videos: []
            };
        }

        // Si l'entr√©e est un nombre, c'est une s√©lection de vid√©o pour t√©l√©chargement
        if (!isNaN(prompt) && prompt > 0) {
            const videoIndex = parseInt(prompt) - 1;
            
            // V√©rifier si l'index est valide
            if (videoIndex >= 0 && videoIndex < userSearches[senderId].videos.length) {
                const selectedVideo = userSearches[senderId].videos[videoIndex];
                
                // Message d'attente
                await sendMessage(senderId, "‚è≥ Pr√©paration du t√©l√©chargement en cours...");
                
                try {
                    // Utiliser l'API ytmusic pour obtenir les informations de t√©l√©chargement
                    const searchUrl = `https://api-library-kohi.onrender.com/api/ytmusic?query=${encodeURIComponent(selectedVideo.title)}`;
                    const searchResponse = await axios.get(searchUrl);
                    
                    if (searchResponse.data && searchResponse.data.status && searchResponse.data.data) {
                        const musicData = searchResponse.data.data;
                        
                        // Construire le message de r√©ponse
                        const messageText = `
üéµ ùó†ùó®ùó¶ùóúùóñ ùó•ùóòùó¶ùó®ùóüùóß üéµ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üé§ ùóßùó∂ùòÅùóøùó≤ : ${musicData.title}

‚è±Ô∏è ùóóùòÇùóøùó≤ÃÅùó≤ : ${musicData.duration}

üëÅÔ∏è ùó©ùòÇùó≤ùòÄ : ${musicData.views.toLocaleString()}

üîó ùóüùó∂ùó≤ùóª : ${musicData.url}

üéß ùóîùòÇùó±ùó∂ùóº : ${musicData.audioUrl}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ú® ùóïùóºùóªùóªùó≤ ùó≤ÃÅùó∞ùóºùòÇùòÅùó≤ ! üé∂
                        `.trim();

                        // Envoyer l'image de la miniature
                        await sendMessage(senderId, {
                            attachment: {
                                type: 'image',
                                payload: {
                                    url: musicData.thumbnail,
                                    is_reusable: true
                                }
                            }
                        });

                        // Envoyer le message texte
                        await sendMessage(senderId, messageText);
                        
                    } else {
                        await sendMessage(senderId, "‚ùå Impossible de r√©cup√©rer le lien de t√©l√©chargement.");
                    }
                } catch (error) {
                    console.error("Erreur lors du t√©l√©chargement:", error);
                    await sendMessage(senderId, "‚ùå D√©sol√©, une erreur s'est produite lors de la pr√©paration du t√©l√©chargement.");
                }
            } else {
                await sendMessage(senderId, "‚ùå Num√©ro de vid√©o invalide. Veuillez choisir un num√©ro valide.");
            }
        } else {
            // C'est une nouvelle recherche
            // Message d'attente
            await sendMessage(senderId, "üîç Recherche en cours...");
            
            // Appel √† l'API de recherche YouTube
            const searchUrl = `https://api-youtube-vraie-vercel.vercel.app/recherche?titre=${encodeURIComponent(prompt)}`;
            const searchResponse = await axios.get(searchUrl);
            
            // V√©rifier si des vid√©os ont √©t√© trouv√©es
            if (searchResponse.data && searchResponse.data.videos && searchResponse.data.videos.length > 0) {
                // Stocker les vid√©os pour cet utilisateur
                userSearches[senderId].query = prompt;
                userSearches[senderId].videos = searchResponse.data.videos;
                
                // Construire la liste des vid√©os
                let message = `üåü *${prompt.toUpperCase()}* üåü\n\n`;
                
                searchResponse.data.videos.forEach((video, index) => {
                    message += `${index + 1}- ${video.title}\n\n`;
                });
                
                message += "‚úÖ *Envoyez le num√©ro* de la vid√©o que vous souhaitez t√©l√©charger.";
                
                // Envoyer la liste des vid√©os
                await sendMessage(senderId, message);
            } else {
                await sendMessage(senderId, "‚ùå Aucune vid√©o trouv√©e pour votre recherche.");
            }
        }
    } catch (error) {
        console.error("Erreur lors de l'ex√©cution de la commande ytb:", error);
        await sendMessage(senderId, "‚ùå D√©sol√©, une erreur s'est produite lors du traitement de votre demande.");
    }
};

// Ajouter les informations de la commande
module.exports.info = {
    name: "ytb",
    description: "Recherche et t√©l√©charge des vid√©os YouTube en format MP3.",
    usage: "Envoyez 'ytb <nom de la chanson ou artiste>' pour rechercher, puis r√©pondez avec le num√©ro de la vid√©o pour t√©l√©charger."
};
