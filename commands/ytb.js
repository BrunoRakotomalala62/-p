
const sendMessage = require('../handles/sendMessage');
const axios = require('axios');

// Stockage des recherches des utilisateurs
const userSearches = {};

module.exports = async (senderId, prompt) => {
    try {
        // V√©rifier si l'utilisateur a d√©j√† effectu√© une recherche
        if (!userSearches[senderId]) {
            userSearches[senderId] = {
                query: '',
                videos: []
            };
        }

        // Si l'entr√©e est un nombre, c'est une s√©lection de vid√©o pour t√©l√©chargement
        if (!isNaN(prompt) && prompt > 0) {
            const videoIndex = parseInt(prompt) - 1;
            
            // V√©rifier si l'index est valide
            if (videoIndex >= 0 && videoIndex < userSearches[senderId].videos.length) {
                const selectedVideo = userSearches[senderId].videos[videoIndex];
                
                // Message d'attente
                await sendMessage(senderId, "‚è≥ Pr√©paration du t√©l√©chargement en cours...");
                
                try {
                    // Utiliser l'API ytmusic pour obtenir les informations de t√©l√©chargement
                    const searchUrl = `https://api-library-kohi.onrender.com/api/ytmusic?query=${encodeURIComponent(selectedVideo.title)}`;
                    const searchResponse = await axios.get(searchUrl);
                    
                    if (searchResponse.data && searchResponse.data.status && searchResponse.data.data) {
                        const musicData = searchResponse.data.data;
                        
                        // Construire le message de r√©ponse
                        const messageText = `
üéµ ùó†ùó®ùó¶ùóúùóñ ùó•ùóòùó¶ùó®ùóüùóß üéµ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üé§ ùóßùó∂ùòÅùóøùó≤ : ${musicData.title}

‚è±Ô∏è ùóóùòÇùóøùó≤ÃÅùó≤ : ${musicData.duration}

üëÅÔ∏è ùó©ùòÇùó≤ùòÄ : ${musicData.views.toLocaleString()}

üîó ùóüùó∂ùó≤ùóª : ${musicData.url}

üéß ùóîùòÇùó±ùó∂ùóº : ${musicData.audioUrl}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ú® ùóïùóºùóªùóªùó≤ ùó≤ÃÅùó∞ùóºùòÇùòÅùó≤ ! üé∂
                        `.trim();

                        // Envoyer l'image de la miniature
                        await sendMessage(senderId, {
                            attachment: {
                                type: 'image',
                                payload: {
                                    url: musicData.thumbnail,
                                    is_reusable: true
                                }
                            }
                        });

                        // Envoyer le message texte
                        await sendMessage(senderId, messageText);
                        
                    } else {
                        await sendMessage(senderId, "‚ùå Impossible de r√©cup√©rer le lien de t√©l√©chargement.");
                    }
                } catch (error) {
                    console.error("Erreur lors du t√©l√©chargement:", error);
                    await sendMessage(senderId, "‚ùå D√©sol√©, une erreur s'est produite lors de la pr√©paration du t√©l√©chargement.");
                }
            } else {
                await sendMessage(senderId, "‚ùå Num√©ro de vid√©o invalide. Veuillez choisir un num√©ro valide.");
            }
        } else {
            // C'est une nouvelle recherche
            // Message d'attente
            await sendMessage(senderId, "üîç Recherche en cours...");
            
            // Appel √† l'API de recherche YouTube
            const searchUrl = `https://api-youtube-vraie-vercel.vercel.app/recherche?titre=${encodeURIComponent(prompt)}`;
            const searchResponse = await axios.get(searchUrl);
            
            // V√©rifier si des vid√©os ont √©t√© trouv√©es
            if (searchResponse.data && searchResponse.data.videos && searchResponse.data.videos.length > 0) {
                // Stocker les vid√©os pour cet utilisateur
                userSearches[senderId].query = prompt;
                
                // Limiter √† 80 r√©sultats maximum
                const allVideos = searchResponse.data.videos.slice(0, 80);
                userSearches[senderId].videos = allVideos;
                
                // Envoyer les r√©sultats par groupes de 20
                const BATCH_SIZE = 20;
                const totalBatches = Math.ceil(allVideos.length / BATCH_SIZE);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIndex = batchIndex * BATCH_SIZE;
                    const endIndex = Math.min(startIndex + BATCH_SIZE, allVideos.length);
                    const batchVideos = allVideos.slice(startIndex, endIndex);
                    
                    // Construire le message pour ce lot
                    let message = '';
                    
                    // Ajouter le titre seulement pour le premier lot
                    if (batchIndex === 0) {
                        message = `üåü *${prompt.toUpperCase()}* üåü\n\n`;
                    }
                    
                    // Ajouter les vid√©os de ce lot
                    batchVideos.forEach((video, index) => {
                        const globalIndex = startIndex + index + 1;
                        message += `${globalIndex}- ${video.title}\n\n`;
                    });
                    
                    // Ajouter les instructions seulement au dernier lot
                    if (batchIndex === totalBatches - 1) {
                        message += `‚úÖ *Envoyez le num√©ro* de la vid√©o que vous souhaitez t√©l√©charger.\n\n`;
                        message += `üìä Total: ${allVideos.length} r√©sultats trouv√©s`;
                    }
                    
                    // Envoyer le message pour ce lot
                    await sendMessage(senderId, message);
                    
                    // Attendre 2 secondes entre chaque lot pour √©viter la surcharge
                    if (batchIndex < totalBatches - 1) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
            } else {
                await sendMessage(senderId, "‚ùå Aucune vid√©o trouv√©e pour votre recherche.");
            }
        }
    } catch (error) {
        console.error("Erreur lors de l'ex√©cution de la commande ytb:", error);
        await sendMessage(senderId, "‚ùå D√©sol√©, une erreur s'est produite lors du traitement de votre demande.");
    }
};

// Ajouter les informations de la commande
module.exports.info = {
    name: "ytb",
    description: "Recherche et t√©l√©charge des vid√©os YouTube en format MP3.",
    usage: "Envoyez 'ytb <nom de la chanson ou artiste>' pour rechercher, puis r√©pondez avec le num√©ro de la vid√©o pour t√©l√©charger."
};
